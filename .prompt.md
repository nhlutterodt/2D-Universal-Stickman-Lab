# 🧩 2D Universal Stickman Lab – Comprehensive Integration Prompts

These prompts are structured for GitHub Copilot in Agent Mode to guide non-destructive integration across modules. Copy each block into your Copilot chat or plugin workflow as needed.

---

### 🔹 Prompt: Integrate Hierarchical Bone Tree with Recursive FK

```markdown
📌 Assumptions:
- Language: TypeScript
- Existing Files: `SkeletonEditor`, `ImprovedSkeletonEditor`, `bone.ts`
- Existing: flat bone list in `Map`, no parent/child structure

🎯 Integrate parent-child bone hierarchy and recursive `updateWorldTransform()` in `Skeleton` system

📚 Context:
#file: skeleton/bone.ts, skeleton/skeleton.ts
@workspace

🧱 Structure:
- Add `parent: Bone | null` and `children: Bone[]` to `Bone`
- Update `SkeletonEditor` to build hierarchy from bone creation
- Implement `updateWorldTransform()` to recursively compute world rotation and position from parent
- Ensure rendering and selection tools respect new hierarchy

💡 Example:
```ts
// Before
bone.rotation = input.rotation;

// After
bone.setParent(parent);
bone.updateWorldTransform(); // applies FK

function updateWorldTransform(bone: Bone) {
  if (bone.parent) {
    bone.worldRotation = bone.parent.worldRotation + bone.localRotation;
    // + position, scale, etc.
  }
}
```

🧑‍💼 Persona: Integrate like a physics engine dev ensuring math propagation consistency

✅ Checklist:
* No FK logic duplication
* Tree traversal with cycle prevention
* Render and input handling work unchanged

🔍 Validation Prompt:
“Select a child bone and rotate its parent—does the child follow correctly in both render and inspector?”
```

---

### 🔹 Prompt: Plug Math Core into Skeleton & IK

```markdown
📌 Assumptions:
* `Vector2` inlined in `index.html`
* No `Matrix3` in project
* Solvers and render code access position, rotation, scale per bone

🎯 Replace inlined math with modular `Vector2`, `Matrix3` and propagate usage across Skeleton and IK systems

📚 Context:
#file: math/vector.ts, math/matrix.ts
@workspace

🧱 Structure:
* Move `Vector2` into `math/vector.ts`, add complete vector ops
* Create `Matrix3` with transform utilities
* Refactor `Skeleton`, `IK`, and `render` modules to use math core
* Apply via constructor injection or direct import to minimize surface change

💡 Example:
```ts
const localMatrix = Matrix3.fromRotation(bone.localRotation)
  .multiply(Matrix3.fromTranslation(bone.localPosition));
bone.worldMatrix = parent.worldMatrix.multiply(localMatrix);
```

✅ Checklist:
* Skeleton and render logic import from `math/`
* No remaining `Math.cos`/`Math.sin` in render loop directly
* Typed arrays used for performance

🔍 Validation Prompt:
“Profile FK update loop with DevTools—do transform ops use math module and avoid allocations?”
```

---

### 🔹 Prompt: Connect FABRIK Solver with Skeleton and UI Constraints

```markdown
📌 Assumptions:
* FABRIK to be added in `ik/solvers/fabrik.ts`
* Bone angle limits already defined in editor UI (min/max sliders)
* Skeleton structure includes parent-child links

🎯 Integrate FABRIK solver with real-time updates from `Skeleton`, applying soft constraints from bone properties

📚 Context:
#file: ik/solvers/fabrik.ts, skeleton/bone.ts, ui/property-panel.ts
@workspace

🧱 Structure:
* Build `solveFABRIK(boneChain, target)` function
* Integrate `minAngle`, `maxAngle`, and bend preference in per-joint solver step
* Use event listeners in UI to update constraint values in `Bone` class
* Invoke solver on drag of IK target and update render

💡 Example:
```ts
if (angle < bone.minAngle) {
  angle = bone.minAngle + softness * (angle - bone.minAngle);
}
```

✅ Checklist:
* Solver respects bone hierarchy
* Constraints applied during iteration (not post-fix)
* Smooth animation under limit changes

🔍 Validation Prompt:
“Drag IK target near joint limit—does joint ease into constraint, not snap?”
```

---

### 🔹 Prompt: Connect Graph Metrics to Animation and Solver Outputs

```markdown
📌 Assumptions:
* `graph-pane` web component is active
* Metrics (length, rotation) tracked but not bound to solver or FK output

🎯 Pipe time-series data from `Skeleton` + `IK` into `graph-pane` for live charting

📚 Context:
#file: ui/graph-pane.ts, skeleton/skeleton.ts, ik/solvers/
@workspace

🧱 Structure:
* Emit events from `Skeleton.updateWorldTransform()` with updated `length`, `angle`
* Stream into `graph-pane` via custom events
* Update Chart.js dataset on frame
* Support export as JSON

💡 Example:
```ts
dispatchEvent(new CustomEvent('metricUpdate', {
  detail: { boneId, time, rotation, length }
}));
```

✅ Checklist:
* Live graph tracks multiple bones
* Data export persists all series
* No perf hit from event streaming

🔍 Validation Prompt:
“Does graph update in real time as FK or IK changes bone positions during interaction?”
```

---

### 🔹 Prompt: Wire Blend Graph Outputs into Skeleton Preview

```markdown
📌 Assumptions:
* Blend graph UI exists (or planned)
* `Skeleton` accepts pose from procedural or keyframe source

🎯 Connect blend graph output node to drive skeleton pose in preview canvas

📚 Context:
#file: animation/blend-graph.ts, skeleton/skeleton.ts, render/canvas.ts
@workspace

🧱 Structure:
* Define `BlendNode` interface with `getPose(): Pose`
* On render frame, blend graph emits a `Pose` (rotation, position per bone)
* Feed result into `Skeleton.setPose()`
* Add toggle to enable/disable blend graph preview

💡 Example:
```ts
const pose = blendGraph.evaluate(currentTime);
skeleton.setPose(pose);
```

✅ Checklist:
* Blend graph interpolates FK/IK layers
* Preview updates on slider/time scrub
* `Skeleton.setPose` applies poses without side effects

🔍 Validation Prompt:
“Toggle IK and keyframe layers—does pose update smoothly without jitter or conflict?”
```
