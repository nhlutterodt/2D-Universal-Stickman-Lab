# ğŸ§© 2D Universal Stickman Lab â€“ Comprehensive Integration Prompts

These prompts are structured for GitHub Copilot in Agent Mode to guide non-destructive integration across modules. Copy each block into your Copilot chat or plugin workflow as needed.

---

### ğŸ”¹ Prompt: Integrate Hierarchical Bone Tree with Recursive FK

```markdown
ğŸ“Œ Assumptions:
- Language: TypeScript
- Existing Files: `SkeletonEditor`, `ImprovedSkeletonEditor`, `bone.ts`
- Existing: flat bone list in `Map`, no parent/child structure

ğŸ¯ Integrate parent-child bone hierarchy and recursive `updateWorldTransform()` in `Skeleton` system

ğŸ“š Context:
#file: skeleton/bone.ts, skeleton/skeleton.ts
@workspace

ğŸ§± Structure:
- Add `parent: Bone | null` and `children: Bone[]` to `Bone`
- Update `SkeletonEditor` to build hierarchy from bone creation
- Implement `updateWorldTransform()` to recursively compute world rotation and position from parent
- Ensure rendering and selection tools respect new hierarchy

ğŸ’¡ Example:
```ts
// Before
bone.rotation = input.rotation;

// After
bone.setParent(parent);
bone.updateWorldTransform(); // applies FK

function updateWorldTransform(bone: Bone) {
  if (bone.parent) {
    bone.worldRotation = bone.parent.worldRotation + bone.localRotation;
    // + position, scale, etc.
  }
}
```

ğŸ§‘â€ğŸ’¼ Persona: Integrate like a physics engine dev ensuring math propagation consistency

âœ… Checklist:
* No FK logic duplication
* Tree traversal with cycle prevention
* Render and input handling work unchanged

ğŸ” Validation Prompt:
â€œSelect a child bone and rotate its parentâ€”does the child follow correctly in both render and inspector?â€
```

---

### ğŸ”¹ Prompt: Plug Math Core into Skeleton & IK

```markdown
ğŸ“Œ Assumptions:
* `Vector2` inlined in `index.html`
* No `Matrix3` in project
* Solvers and render code access position, rotation, scale per bone

ğŸ¯ Replace inlined math with modular `Vector2`, `Matrix3` and propagate usage across Skeleton and IK systems

ğŸ“š Context:
#file: math/vector.ts, math/matrix.ts
@workspace

ğŸ§± Structure:
* Move `Vector2` into `math/vector.ts`, add complete vector ops
* Create `Matrix3` with transform utilities
* Refactor `Skeleton`, `IK`, and `render` modules to use math core
* Apply via constructor injection or direct import to minimize surface change

ğŸ’¡ Example:
```ts
const localMatrix = Matrix3.fromRotation(bone.localRotation)
  .multiply(Matrix3.fromTranslation(bone.localPosition));
bone.worldMatrix = parent.worldMatrix.multiply(localMatrix);
```

âœ… Checklist:
* Skeleton and render logic import from `math/`
* No remaining `Math.cos`/`Math.sin` in render loop directly
* Typed arrays used for performance

ğŸ” Validation Prompt:
â€œProfile FK update loop with DevToolsâ€”do transform ops use math module and avoid allocations?â€
```

---

### ğŸ”¹ Prompt: Connect FABRIK Solver with Skeleton and UI Constraints

```markdown
ğŸ“Œ Assumptions:
* FABRIK to be added in `ik/solvers/fabrik.ts`
* Bone angle limits already defined in editor UI (min/max sliders)
* Skeleton structure includes parent-child links

ğŸ¯ Integrate FABRIK solver with real-time updates from `Skeleton`, applying soft constraints from bone properties

ğŸ“š Context:
#file: ik/solvers/fabrik.ts, skeleton/bone.ts, ui/property-panel.ts
@workspace

ğŸ§± Structure:
* Build `solveFABRIK(boneChain, target)` function
* Integrate `minAngle`, `maxAngle`, and bend preference in per-joint solver step
* Use event listeners in UI to update constraint values in `Bone` class
* Invoke solver on drag of IK target and update render

ğŸ’¡ Example:
```ts
if (angle < bone.minAngle) {
  angle = bone.minAngle + softness * (angle - bone.minAngle);
}
```

âœ… Checklist:
* Solver respects bone hierarchy
* Constraints applied during iteration (not post-fix)
* Smooth animation under limit changes

ğŸ” Validation Prompt:
â€œDrag IK target near joint limitâ€”does joint ease into constraint, not snap?â€
```

---

### ğŸ”¹ Prompt: Connect Graph Metrics to Animation and Solver Outputs

```markdown
ğŸ“Œ Assumptions:
* `graph-pane` web component is active
* Metrics (length, rotation) tracked but not bound to solver or FK output

ğŸ¯ Pipe time-series data from `Skeleton` + `IK` into `graph-pane` for live charting

ğŸ“š Context:
#file: ui/graph-pane.ts, skeleton/skeleton.ts, ik/solvers/
@workspace

ğŸ§± Structure:
* Emit events from `Skeleton.updateWorldTransform()` with updated `length`, `angle`
* Stream into `graph-pane` via custom events
* Update Chart.js dataset on frame
* Support export as JSON

ğŸ’¡ Example:
```ts
dispatchEvent(new CustomEvent('metricUpdate', {
  detail: { boneId, time, rotation, length }
}));
```

âœ… Checklist:
* Live graph tracks multiple bones
* Data export persists all series
* No perf hit from event streaming

ğŸ” Validation Prompt:
â€œDoes graph update in real time as FK or IK changes bone positions during interaction?â€
```

---

### ğŸ”¹ Prompt: Wire Blend Graph Outputs into Skeleton Preview

```markdown
ğŸ“Œ Assumptions:
* Blend graph UI exists (or planned)
* `Skeleton` accepts pose from procedural or keyframe source

ğŸ¯ Connect blend graph output node to drive skeleton pose in preview canvas

ğŸ“š Context:
#file: animation/blend-graph.ts, skeleton/skeleton.ts, render/canvas.ts
@workspace

ğŸ§± Structure:
* Define `BlendNode` interface with `getPose(): Pose`
* On render frame, blend graph emits a `Pose` (rotation, position per bone)
* Feed result into `Skeleton.setPose()`
* Add toggle to enable/disable blend graph preview

ğŸ’¡ Example:
```ts
const pose = blendGraph.evaluate(currentTime);
skeleton.setPose(pose);
```

âœ… Checklist:
* Blend graph interpolates FK/IK layers
* Preview updates on slider/time scrub
* `Skeleton.setPose` applies poses without side effects

ğŸ” Validation Prompt:
â€œToggle IK and keyframe layersâ€”does pose update smoothly without jitter or conflict?â€
```
